<!DOCTYPE html>
<html lang="en">
<head>
    <style>
        table {
            font-family: arial, sans-serif;
            border-collapse: collapse;
            width: 100%;
        }

        td, th {
            border: 1px solid #dddddd;
            text-align: left;
            padding: 8px;
        }

        th {
            background-color: #dddddd;
        }

        tr:nth-child(even) {
            background-color: #dddddd;
        }
    </style>
    <meta charset="UTF-8">
    <title>Inicio</title>
</head>
<body>
<button onclick="new Transaction().getProposalTxs()">Reload</button>
<br />
<table id="table">
    <thead>
        <tr>
            <th>Wallet</th>
            <th>Amount received</th>
            <th>Titles</th>
        </tr>
    </thead>
    <tbody id="tableBody">
        <tr>
            <td>
                Loading
            </td>
            <td>
                Loading
            </td>
            <td>
                Loading
            </td>
        </tr>
    </tbody>

</table>
<script>
    document.addEventListener('DOMContentLoaded',()=>new Transaction().getProposalTxs())
    function numberWithCommas(x) {
        var parts = x.toString().split(".");
        parts[0] = parts[0].replace(/\B(?=(\d{3})+(?!\d))/g, ",");
        return parts.join(".");
    }

    function loadTableData(items) {
        const table = document.getElementById('table')
        const tableBody = document.getElementById("tableBody");
        const tbody = document.createElement('tbody')
        tbody.setAttribute('id','tableBody')
        table.deleteRow(0)
        items.forEach( item => {
            let row = tbody.insertRow();
            let addr = row.insertCell(0);
            addr.innerHTML = item.addr;
            let amount = row.insertCell(1);
            amount.innerHTML = numberWithCommas(item.amount);
            let title = row.insertCell(2);
            title.innerHTML = item.titles;
            title.style.whiteSpace = "pre-wrap"
        });
        table.replaceChild(tbody,tableBody)
    }
    class Request
    {
        attributes = null;
        body = null;
        headers = {
            Accept: this.constructor.HEADER_CONTENT_TYPE,
        };
        method = 'GET';

        static get HEADER_CONTENT_TYPE()
        {
            return '*/*';
        }

        getLcdBaseUrl()
        {
            return 'https://phoenix-lcd.terra.dev';
        }

        getFcdBaseUrl()
        {
            return 'https://phoenix-fcd.terra.dev';
        }

        getType()
        {
            return this.constructor.name;
        }

        send(url, attributes)
        {
            const method = this.method;
            if (attributes && (method === 'PATCH' || method === 'POST'))
            {
                if (typeof attributes !== 'string')
                {
                    this.body = JSON.stringify(
                        {
                            data : {
                                attributes,
                                id   : token,
                                type : this.getType()
                            }
                        }
                    );
                }
            }
            return fetch(url, this);
        }
    }

    class Transaction extends Request
    {
        async getProposalTxs(){
            const proposals=await this.getProposals()
            const executedProposals=proposals.filter((proposal)=>proposal.status==="executed")
            const executedProposalsInfo=executedProposals.map((proposal)=>({description:proposal.description,title:proposal.title,bank:proposal.msgs.reduce((bank,current)=>({...current?.bank})??bank, null)}))
            const receivers = executedProposalsInfo.map(proposal=>proposal.bank.send.to_address)
            const uniqReceivers = [...new Set(receivers)];
            const amountAndAddrAndDescriptions= executedProposalsInfo.map(proposal=>({addr:proposal.bank.send.to_address,amount:(parseInt(proposal.bank.send.amount[0].amount,10)/1000000), title:proposal.title}))
            const amountPerAddr = uniqReceivers.map(addr=>({addr,amount:amountAndAddrAndDescriptions.reduce((totalAmount,currentAddr)=>totalAmount + (currentAddr.addr===addr?currentAddr.amount:0),0),titles:amountAndAddrAndDescriptions.reduce((concatTitles,current)=>(current.addr===addr?concatTitles.concat(current.title,"\n"):concatTitles),"")}))
            const sortedAddressByAmount=amountPerAddr.sort((a,b)=>b.amount-a.amount)
            loadTableData(sortedAddressByAmount)
        }
        async getTransferTxs(){
            const txs=await this.getTxs()
            const transferTxs=txs.filter(tx=>tx.logs[0]?.events.reduce((isTransfer,currentEvent)=>isTransfer||(currentEvent.type==="transfer"),false))
            // const totalAmount = transferTxs.reduce((totalAmount, currentTx)=>totalAmount + currentTx.logs[0].events.reduce((amount, currentEvent)=>currentEvent.type==="transfer"?currentEvent.attributes.reduce((amount,currentAttr)=> (currentAttr.key === "amount" && currentAttr.value!=="") ? (parseInt(currentAttr.value.replace("uluna", ""), 10) / 1000000) : amount,0):amount,0),0)
            // const bigTransferTxs=transferTxs.filter(tx=>tx.logs[0]?.events.reduce((isBigTransfer,currentEvent)=>isBigTransfer||(currentEvent.type==="transfer"?currentEvent.attributes.reduce((isBigTransfer,currentAttr)=>currentAttr.key==="amount"?((parseInt(currentAttr.value.replace("uluna",""),10)/1000000)>10000):isBigTransfer,false):false),false))
            const receivers = transferTxs.map(tx=>tx.logs[0].events.reduce((receiverAddr, currentEvent)=>currentEvent.type==="transfer"?currentEvent.attributes.reduce((receiverAddr,currentAttr)=>currentAttr.key==="recipient"?currentAttr.value:receiverAddr,null):receiverAddr,null),null)
            const uniqReceivers = [...new Set(receivers)];
            const amountAndAddr = transferTxs.map(tx=>({addr:tx.logs[0].events.reduce((receiverAddr,currentEvent)=>currentEvent.type==="transfer"?currentEvent.attributes.reduce((receiverAddr,currentAttr)=>currentAttr.key==="recipient"?currentAttr.value:receiverAddr,null):receiverAddr,null),amount:tx.logs[0].events.reduce((amount,currentEvent)=>currentEvent.type==="transfer"?currentEvent.attributes.reduce((amount,currentAttr)=>(currentAttr.key==="amount" && currentAttr.value!=="")?(parseInt(currentAttr.value.replace("uluna", ""), 10) / 1000000):amount,0):amount,0)}))
            const amountPerAddr = uniqReceivers.map(addr=>({addr,amount:amountAndAddr.reduce((totalAmount,currentAddr)=>totalAmount + (currentAddr.addr===addr?currentAddr.amount:0),0)}))
            const sortedAddressByAmount=amountPerAddr.sort((a,b)=>b.amount-a.amount)
            loadTableData(sortedAddressByAmount)
        }
       async getTxs()
        {
            this.method = 'GET';
            let txs;
            let nextUpdate
            const currentDate=new Date()
            const tomorrow = new Date()
            tomorrow.setDate(tomorrow.getDate() + 1)
            if(localStorage.getItem('nextUpdate')){
                nextUpdate = parseInt(localStorage.getItem('nextUpdate'),10)
            }else{
                nextUpdate = 0
            }
            let keepGoing = (currentDate.getTime() >= nextUpdate) ;
            if(keepGoing===false && localStorage.getItem('txs')){
                txs=JSON.parse(localStorage.getItem('txs'))
            }else{
                txs=[]
            }
            let offset = 0;
            while (keepGoing) {
                let response = await this.send(`${this.getFcdBaseUrl()}/v1/txs?offset=${offset}&limit=100&account=terra1exqfh9ahyzm9g8z3ce57eyuxx72vem63utepjsf6stqtrztyz58spaf8ew`);
                let data = await response.json()
                txs.push.apply(txs, data.txs);
                offset = data.next;
                // this may need to be adjusted to your api to handle the corner case where the last page size equal to PAGE_SIZE
                // if the api either errors our the next call where the offset is greater than the amount of records or returns an empty array
                // the behavior will be fine.
                if (!data.next) {
                    keepGoing = false;
                    localStorage.setItem("nextUpdate",tomorrow.getTime().toString())
                    localStorage.setItem("txs",JSON.stringify(txs))
                }
            }
            return txs;
        }
        async getProposals()
        {
            this.method = 'GET';
            let txs;
            let nextUpdate
            let keepGoing=true
            const currentDate=new Date()
            const tomorrow = new Date()
            tomorrow.setDate(tomorrow.getDate() + 1)
            if(localStorage.getItem('nextUpdate')){
                nextUpdate = parseInt(localStorage.getItem('nextUpdate'),10)
            }else{
                nextUpdate = 0
            }
            if (localStorage.getItem('proposals')){
                keepGoing = (currentDate.getTime() >= nextUpdate) ;
            }
            if(keepGoing===false && localStorage.getItem('proposals')){
                txs=JSON.parse(localStorage.getItem('proposals'))
            }else{
                txs=[]
            }
            let offset = 0;
            while (keepGoing) {
                let base64Query = this.objectToBase64({
                    "list_proposals":{"limit":(offset+30),"start_after":offset}
                })
                let response = await this.send(`${this.getLcdBaseUrl()}/cosmwasm/wasm/v1/contract/terra1exqfh9ahyzm9g8z3ce57eyuxx72vem63utepjsf6stqtrztyz58spaf8ew/smart/${base64Query}`);
                let data = await response.json()
                txs.push.apply(txs, data.data.proposals);
                offset += 30;
                // this may need to be adjusted to your api to handle the corner case where the last page size equal to PAGE_SIZE
                // if the api either errors our the next call where the offset is greater than the amount of records or returns an empty array
                // the behavior will be fine.
                if (data.data.proposals.length<30) {
                    keepGoing = false;
                    localStorage.setItem("nextUpdate",tomorrow.getTime().toString())
                    localStorage.setItem("proposals",JSON.stringify(txs))
                }
            }
            return txs;
        }

        objectToBase64(obj){
            return btoa(JSON.stringify(obj))
        }
        base64ToObject(base64){
            return JSON.parse(atob(base64))
        }

        getFcdBaseUrl()
        {
            return super.getFcdBaseUrl();
        }
        getLcdBaseUrl()
        {
            return super.getLcdBaseUrl();
        }
    }
</script>
</body>
</html>
