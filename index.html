<!DOCTYPE html>
<html lang="en">
<head>
    <style>
        table {
            font-family: arial, sans-serif;
            border-collapse: collapse;
            width: 100%;
        }

        td, th {
            border: 1px solid #dddddd;
            text-align: left;
            padding: 8px;
        }

        th {
            background-color: #dddddd;
        }

        tr:nth-child(even) {
            background-color: #dddddd;
        }
    </style>
    <meta charset="UTF-8">
    <title>Inicio</title>
</head>
<body>
<button onclick="new Transaction().getTransferTxs()">Get all txs</button>
<br />
<table id="table">
    <thead>
        <tr>
            <th>Wallet</th>
            <th>Amount received</th>
        </tr>
    </thead>
    <tbody id="tableBody">
        <tr>
            <td>
                Loading
            </td>
            <td>
                Loading
            </td>
        </tr>
    </tbody>

</table>
<script>
    function numberWithCommas(x) {
        var parts = x.toString().split(".");
        parts[0] = parts[0].replace(/\B(?=(\d{3})+(?!\d))/g, ",");
        return parts.join(".");
    }

    function loadTableData(items) {
        const table = document.getElementById("tableBody");
        table.deleteRow(0)
        items.forEach( item => {
            let row = table.insertRow();
            let addr = row.insertCell(0);
            addr.innerHTML = item.addr;
            let amount = row.insertCell(1);
            amount.innerHTML = numberWithCommas(item.amount);
        });
    }
    class Request
    {
        attributes = null;
        body = null;
        headers = {
            Accept: this.constructor.HEADER_CONTENT_TYPE,
        };
        method = 'GET';

        static get HEADER_CONTENT_TYPE()
        {
            return '*/*';
        }



        getBaseUrl()
        {
            return 'https://phoenix-fcd.terra.dev';
        }

        getType()
        {
            return this.constructor.name;
        }

        send(url, attributes)
        {
            const method = this.method;
            if (attributes && (method === 'PATCH' || method === 'POST'))
            {
                if (typeof attributes !== 'string')
                {
                    this.body = JSON.stringify(
                        {
                            data : {
                                attributes,
                                id   : token,
                                type : this.getType()
                            }
                        }
                    );
                }
            }
            return fetch(url, this);
        }

        setToken(token)
        {
            return (this.constructor.token = token);
        }
    }

    class Transaction extends Request
    {
        async getTransferTxs(){
            const txs=await this.getTxs()
            const transferTxs=txs.filter(tx=>tx.logs[0]?.events.reduce((isTransfer,currentEvent)=>isTransfer||(currentEvent.type==="transfer"),false))
            console.log(transferTxs)
            const totalAmount = transferTxs.reduce((totalAmount, currentTx)=>totalAmount + currentTx.logs[0].events.reduce((amount, currentEvent)=>currentEvent.type==="transfer"?currentEvent.attributes.reduce((amount,currentAttr)=> (currentAttr.key === "amount" && currentAttr.value!=="") ? (parseInt(currentAttr.value.replace("uluna", ""), 10) / 1000000) : amount,0):amount,0),0)
            console.log(totalAmount)
            const bigTransferTxs=transferTxs.filter(tx=>tx.logs[0]?.events.reduce((isBigTransfer,currentEvent)=>isBigTransfer||(currentEvent.type==="transfer"?currentEvent.attributes.reduce((isBigTransfer,currentAttr)=>currentAttr.key==="amount"?((parseInt(currentAttr.value.replace("uluna",""),10)/1000000)>10000):isBigTransfer,false):false),false))
            console.log(bigTransferTxs)
            const receivers = bigTransferTxs.map(tx=>tx.logs[0].events.reduce((receiverAddr, currentEvent)=>currentEvent.type==="transfer"?currentEvent.attributes.reduce((receiverAddr,currentAttr)=>currentAttr.key==="recipient"?currentAttr.value:receiverAddr,null):receiverAddr,null),null)
            console.log(receivers)
            const uniqReceivers = [...new Set(receivers)];
            console.log(uniqReceivers)
            const amountAndAddr = transferTxs.map(tx=>({addr:tx.logs[0].events.reduce((receiverAddr,currentEvent)=>currentEvent.type==="transfer"?currentEvent.attributes.reduce((receiverAddr,currentAttr)=>currentAttr.key==="recipient"?currentAttr.value:receiverAddr,null):receiverAddr,null),amount:tx.logs[0].events.reduce((amount,currentEvent)=>currentEvent.type==="transfer"?currentEvent.attributes.reduce((amount,currentAttr)=>(currentAttr.key==="amount" && currentAttr.value!=="")?(parseInt(currentAttr.value.replace("uluna", ""), 10) / 1000000):amount,0):amount,0)}))
            console.log(amountAndAddr)
            const amountPerAddr = uniqReceivers.map(addr=>({addr,amount:amountAndAddr.reduce((totalAmount,currentAddr)=>totalAmount + (currentAddr.addr===addr?currentAddr.amount:0),0)}))
            console.log(amountPerAddr)
            const sortedAddressByAmount=amountPerAddr.sort((a,b)=>b.amount-a.amount)
            console.log(sortedAddressByAmount)
            loadTableData(sortedAddressByAmount)
        }
       async getTxs()
        {
            this.method = 'GET';
            let txs = localStorage.getItem('txs')?JSON.parse(localStorage.getItem('txs')):[];
            const currentDate=new Date()
            const tomorrow = currentDate.setDate(currentDate.getDate() + 1)
            let lastUpdate = localStorage.getItem('lastUpdate') || null
            let keepGoing = lastUpdate?(currentDate.getTime() <= lastUpdate):true ;
            let offset = 0;
            while (keepGoing) {
                let response = await this.send(`${this.getBaseUrl()}/v1/txs?offset=${offset}&limit=100&account=terra1exqfh9ahyzm9g8z3ce57eyuxx72vem63utepjsf6stqtrztyz58spaf8ew`);
                let data = await response.json()
                txs.push.apply(txs, data.txs);
                offset = data.next;
                // this may need to be adjusted to your api to handle the corner case where the last page size equal to PAGE_SIZE
                // if the api either errors our the next call where the offset is greater than the amount of records or returns an empty array
                // the behavior will be fine.
                if (!data.next) {
                    keepGoing = false;
                    localStorage.setItem("lastUpdate",tomorrow)
                    localStorage.setItem("txs",JSON.stringify(txs))
                }
            }
            return txs;
        }

        getBaseUrl()
        {
            return super.getBaseUrl();
        }
    }
</script>
</body>
</html>
